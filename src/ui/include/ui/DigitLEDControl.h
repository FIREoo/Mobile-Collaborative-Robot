// Generated by gencpp from file joyControl/DigitLEDControl.msg
// DO NOT EDIT!

#ifndef JOYCONTROL_MESSAGE_DIGITLEDCONTROL_H
#define JOYCONTROL_MESSAGE_DIGITLEDCONTROL_H

#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

namespace joyControl
{
  template <class ContainerAllocator>
  struct DigitLEDControl_
  {
    typedef DigitLEDControl_<ContainerAllocator> Type;

    DigitLEDControl_()
        : left_dig_led(false), right_dig_led(false), left_run_time(0.0), right_run_time(0.0)
    {
    }
    DigitLEDControl_(const ContainerAllocator &_alloc)
        : left_dig_led(false), right_dig_led(false), left_run_time(0.0), right_run_time(0.0)
    {
      (void)_alloc;
    }

    typedef uint8_t _left_dig_led_type;
    _left_dig_led_type left_dig_led;

    typedef uint8_t _right_dig_led_type;
    _right_dig_led_type right_dig_led;

    typedef float _left_run_time_type;
    _left_run_time_type left_run_time;

    typedef float _right_run_time_type;
    _right_run_time_type right_run_time;

    typedef boost::shared_ptr<::joyControl::DigitLEDControl_<ContainerAllocator>> Ptr;
    typedef boost::shared_ptr<::joyControl::DigitLEDControl_<ContainerAllocator> const> ConstPtr;

  }; // struct DigitLEDControl_

  typedef ::joyControl::DigitLEDControl_<std::allocator<void>> DigitLEDControl;

  typedef boost::shared_ptr<::joyControl::DigitLEDControl> DigitLEDControlPtr;
  typedef boost::shared_ptr<::joyControl::DigitLEDControl const> DigitLEDControlConstPtr;

  // constants requiring out of line definition

  template <typename ContainerAllocator>
  std::ostream &operator<<(std::ostream &s, const ::joyControl::DigitLEDControl_<ContainerAllocator> &v)
  {
    ros::message_operations::Printer<::joyControl::DigitLEDControl_<ContainerAllocator>>::stream(s, "", v);
    return s;
  }

  template <typename ContainerAllocator1, typename ContainerAllocator2>
  bool operator==(const ::joyControl::DigitLEDControl_<ContainerAllocator1> &lhs, const ::joyControl::DigitLEDControl_<ContainerAllocator2> &rhs)
  {
    return lhs.left_dig_led == rhs.left_dig_led &&
           lhs.right_dig_led == rhs.right_dig_led &&
           lhs.left_run_time == rhs.left_run_time &&
           lhs.right_run_time == rhs.right_run_time;
  }

  template <typename ContainerAllocator1, typename ContainerAllocator2>
  bool operator!=(const ::joyControl::DigitLEDControl_<ContainerAllocator1> &lhs, const ::joyControl::DigitLEDControl_<ContainerAllocator2> &rhs)
  {
    return !(lhs == rhs);
  }

} // namespace joyControl

namespace ros
{
  namespace message_traits
  {

    template <class ContainerAllocator>
    struct IsMessage<::joyControl::DigitLEDControl_<ContainerAllocator>>
        : TrueType
    {
    };

    template <class ContainerAllocator>
    struct IsMessage<::joyControl::DigitLEDControl_<ContainerAllocator> const>
        : TrueType
    {
    };

    template <class ContainerAllocator>
    struct IsFixedSize<::joyControl::DigitLEDControl_<ContainerAllocator>>
        : TrueType
    {
    };

    template <class ContainerAllocator>
    struct IsFixedSize<::joyControl::DigitLEDControl_<ContainerAllocator> const>
        : TrueType
    {
    };

    template <class ContainerAllocator>
    struct HasHeader<::joyControl::DigitLEDControl_<ContainerAllocator>>
        : FalseType
    {
    };

    template <class ContainerAllocator>
    struct HasHeader<::joyControl::DigitLEDControl_<ContainerAllocator> const>
        : FalseType
    {
    };

    template <class ContainerAllocator>
    struct MD5Sum<::joyControl::DigitLEDControl_<ContainerAllocator>>
    {
      static const char *value()
      {
        return "5fcb3983ee7f931b51ef2d1803e3ef6a";
      }

      static const char *value(const ::joyControl::DigitLEDControl_<ContainerAllocator> &) { return value(); }
      static const uint64_t static_value1 = 0x5fcb3983ee7f931bULL;
      static const uint64_t static_value2 = 0x51ef2d1803e3ef6aULL;
    };

    template <class ContainerAllocator>
    struct DataType<::joyControl::DigitLEDControl_<ContainerAllocator>>
    {
      static const char *value()
      {
        return "joyControl/DigitLEDControl";
      }

      static const char *value(const ::joyControl::DigitLEDControl_<ContainerAllocator> &) { return value(); }
    };

    template <class ContainerAllocator>
    struct Definition<::joyControl::DigitLEDControl_<ContainerAllocator>>
    {
      static const char *value()
      {
        return "bool left_dig_led\n"
               "bool right_dig_led\n"
               "float32 left_run_time\n"
               "float32 right_run_time\n";
      }

      static const char *value(const ::joyControl::DigitLEDControl_<ContainerAllocator> &) { return value(); }
    };

  } // namespace message_traits
} // namespace ros

namespace ros
{
  namespace serialization
  {

    template <class ContainerAllocator>
    struct Serializer<::joyControl::DigitLEDControl_<ContainerAllocator>>
    {
      template <typename Stream, typename T>
      inline static void allInOne(Stream &stream, T m)
      {
        stream.next(m.left_dig_led);
        stream.next(m.right_dig_led);
        stream.next(m.left_run_time);
        stream.next(m.right_run_time);
      }

      ROS_DECLARE_ALLINONE_SERIALIZER
    }; // struct DigitLEDControl_

  } // namespace serialization
} // namespace ros

namespace ros
{
  namespace message_operations
  {

    template <class ContainerAllocator>
    struct Printer<::joyControl::DigitLEDControl_<ContainerAllocator>>
    {
      template <typename Stream>
      static void stream(Stream &s, const std::string &indent, const ::joyControl::DigitLEDControl_<ContainerAllocator> &v)
      {
        s << indent << "left_dig_led: ";
        Printer<uint8_t>::stream(s, indent + "  ", v.left_dig_led);
        s << indent << "right_dig_led: ";
        Printer<uint8_t>::stream(s, indent + "  ", v.right_dig_led);
        s << indent << "left_run_time: ";
        Printer<float>::stream(s, indent + "  ", v.left_run_time);
        s << indent << "right_run_time: ";
        Printer<float>::stream(s, indent + "  ", v.right_run_time);
      }
    };

  } // namespace message_operations
} // namespace ros

#endif // JOYCONTROL_MESSAGE_DIGITLEDCONTROL_H
